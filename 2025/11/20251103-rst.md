---
layout: post
title: "rust: &str と String を分かって使い分けたい"
tags:
  - rust
date: "2025/11/03"
---

Rust で固定文字列を使うことがある。  
そのとき、`"ほにゃほにゃ"` と書いて、vscode で波線が出てきたら `.to_string()` を付けている。  
関数の引数にするときは `&str` を使ってよいかよくわからないので考えずに `&String` を使っている。

これはよろしくなかろう。

## Rust の文字列

* [文字列でUTF-8でエンコードされたテキストを保持する - The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/ch08-02-strings.html)

まず `str` はプリミティブ型の[文字列スライス](https://doc.rust-lang.org/std/primitive.str.html)。  
その借用が `&str`。  
固定文字列の `"ほにゃほにゃ"` は `&str` というガイド表示が出てくる(vscode)のでそうなのだろう。  
`str` 単独では使えなかったと思う。`str::from_utf8()` のような使い方はあるようだ。  
なんとなくプリミティブ型というのはオブジェクトではないというイメージがあったが、[`std:str`](https://doc.rust-lang.org/std/str/index.html) には構造体がたくさんあった。
`u32` などもメソッドはたくさんあるし、そういうものだと思っておけば良いのだろう。

`String` は [`std::String`](https://doc.rust-lang.org/std/string/struct.String.html) の一員だ。  
`str` ページの URL が `std/primitive.str.html` こちらは `std/string/struct.String.html` なので構造体と思っておけば良いか。  
[中身](https://doc.rust-lang.org/src/alloc/string.rs.html#360) はこれだけだ。

```rust
pub struct String {
    vec: Vec<u8>,
}
```

## 固定文字列

[strの説明](https://doc.rust-lang.org/std/primitive.str.html) からすると、固定文字列(string literal)を明示的に書くと `&'static str` とのこと。  
ライフタイムがプログラム全体という意味らしい。
プログラムに直接埋め込まれていてずっと有効というだけだろう。

明示的に書かなくても固定文字列であることに変わりは無いので、変数が見えるならプログラム全体でいつでも有効ということになる。

`str` ではなく `&str` なのも、貸し借りできないというか、動かすことができない常に借用されたデータとしてしか使用できないという意味なのだと思う。
ただ `'static` は「プログラムで固定」の意味が強そうだ。

## Deref

`String` には [Deref<Target = str>](https://doc.rust-lang.org/std/string/struct.String.html#deref) というものがある。  
しかし `String::Deref` の説明に出てくるコードのどこが参照外しなのだろう。

```rust
fn takes_str(s: &str) { }
let s = String::from("Hello");
takes_str(&s);
```

`String` から `&str` のように構造体(スマートポインタ？)を参照で扱うのも Deref なのだろう。  
これがあるから `&str` なのか `String` なのかだんだんわからなくなってくるのだと思う。

* [Derefトレイトでスマートポインタを普通の参照のように扱う - The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/ch15-02-deref.html)
  * [Derefトレイトを実装して型を参照のように扱う](https://doc.rust-jp.rs/book-ja/ch15-02-deref.html#deref%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%A6%E5%9E%8B%E3%82%92%E5%8F%82%E7%85%A7%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E6%89%B1%E3%81%86)

これがないと `&str` から `String` にできるのにその逆がないので面倒なことになりそう。。。  
と思ったが、`.as_str()` を呼び出しているだけなのか。

```rust
impl ops::Deref for String {
    type Target = str;

    #[inline]
    fn deref(&self) -> &str {
        self.as_str()
    }
}
```
