---
layout: post
title: "rust: tokio::broadcast と tokio::mpsc の recv はちょっと違う"
tags:
  - rust
date: "2025/11/28"
---

`tokio::spawn()` したスレッド間の通知に `tokio::mpsc::channel` を使っていた。  
その後、ブロードキャストしたいシーンがあって `tokio::broadcast` を追加したのだが、
`tx.send()` を実行しているのに `rx.recv().await` が全然動作しない。  
どちらも常駐していて `loop {}` させていて、`tx.send()` する方は `thread::sleep()` で 10秒おきくらいに送信していた。

Gemini氏に聞いてみると send 後に `tokio::task::yield_now()` するとよかろうと。  
やってみると、確かに recv.await が解除されて進んだ。  
えー、なんでー。

## tokio::spawn() は Linuxでいうスレッドではない

なんとなくそうじゃないかと思っていたのだが、違うそうだ。  
Go でいうところの goroutine、いわゆる coroutine というのかな？  
軽量スレッドというところか(昔はスレッドが"軽量プロセス"って呼び方だった。pthreadではなかったかも。)。

だから、というわけでもないかもしれないが `thread::sleep()` したからといってスレッドが切り替えされるわけではないそうだ。
send と recv のタスクが同じスレッドで動いていたら、いくらスリープしても切り替わる効果はない(同じスレッド全部が止まる)。
`tokio::task::yield_now()` は tokio のスケジューラに処理を返すので、今回のような場合に効果がある。

`tokio::mpsc` ではそういうことを気にしなかったのだが、これは tx に対して rx が遅いと tx がサスペンドするらしい。
"Backpressure(背圧制御)" というらしい。

・・・と Gemini氏は言う。  
さんざん AI にだまされてきたので信用しづらいが、少なくとも理屈は合いそうだし、実際動いた。  
[tokio::mpsc](https://docs.rs/tokio/latest/tokio/sync/mpsc/index.html) には "backpressure" とは書いてあるが、
それが処理の切り替えどうこうとは書いていない。容量が上限に達したらとかそういう文脈で書いてある。

"backpressure" は、処理能力を超えたデータが送られてきたときに送信元に対して流量制限を掛けるしくみや圧力をいうらしい。

* [バックプレッシャーとは - IT用語辞典 e-Words](https://e-words.jp/w/%E3%83%90%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%83%E3%82%B7%E3%83%A3%E3%83%BC.html)

[tokio::broadcast](https://docs.rs/tokio/latest/tokio/sync/broadcast/index.html) からは読み取れないなあ。

ChatGPT 氏には `thread::sleep()` だとスレッド自体ブロックするから `tokio::time::sleep().await;` にしなされ、という提案をもらった。  
`yield_now()` とどちらがよいかは中身次第だが、tokio のものは tokio に返しなさい、というところか。
