---
layout: post
title: "clang: テストはバイナリを分けようと思う"
tags:
  - clang
date: "2025/09/14"
---

相変わらず C言語で自作したプロジェクトのテストを書いている。

[fff](https://github.com/meekrosoft/fff) でスタブを書いているが、外部のライブラリではなく自作の関数もスタブにしたいことがある。
つまり、A関数のテストをしたいが A関数は中で別ファイルの B関数を呼び出していて、その B関数をスタブにしたい。

もちろん、B関数をリンクしなければ他と同じように `FAKE_VALUE_FUNC()` などを使えばよいのだが、B関数を含んだファイルもテストしたいのでそうはいかない。
じゃあソースコードを `#include` しつつ、それを `namespace` で囲めばファイル単位になるではないか、となるのだが、
今度は `FAKE_VALUE_FUNC()` を複数のファイルで使うとリンクがおかしくなる。  
じゃあ `FAKE_VALUE_FUNC()` も `namespace` で囲めばよいかと思ったのだが、それはそれでうまくいかない。

GCC の [Weak Functions](https://github.com/meekrosoft/fff/blob/5111c61e1ef7848e3afd3550044a8cf4405f4199/README.md#weak-functions)を使ったサンプルもあるので、
弱々にしてしまえばいけるのかとあれこれやったが、どうにもうまくいかない。

あきらめて Weak Function での examples/weak_linking サンプルを実際にビルドしたのだが、あー、これは結局バイナリをファイルごとに作ったのね。  
おそらくだが、

* `DECLARE_FAKE_VALUE_FUNC()` と `DEFINE_FAKE_VALUE_FUNC()` でスタブを別ファイルにまとめ、
* 自作関数も全部スタブを作り、
* スタブたちは全部ライブラリにし、
* あとはテスト関数ごとにライブラリをリンクしたバイナリを作る

、ということだろう。  
スタブの方を weak 定義にしておくと、他になければそれを使うし、本物があるならそちらが使われるということになるはずだ。

まあそうよね。  
1つのバイナリにしようとものすごく時間を使ったけど、テストでがんばるのはそこじゃないよね。。。  
