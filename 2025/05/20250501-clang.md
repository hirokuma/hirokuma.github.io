# clang: ccan/tal (2)

_2025/05/01_

[前回](/2025/04/20250430-clang.html)の続き。

## talサンプルの中身

[ccan/tal](https://ccodearchive.net/info/tal.html) に載っていたサンプルをそのまま動かせるようにしただけである。

* [hirokuma/c-ccan-tal-example](https://github.com/hirokuma/c-ccan-tal-example)

ビルドした実行ファイルの第1引数にコマンド名を書くと、カレントディレクトリにある `hello` を第1引数にして実行するだけのプログラムである。  
あまり動的メモリをどうこうすることがなさそうな挙動だが、まあそこはサンプルなので。

まず、構造体 1つ分を `tal(ctx, struct command)` で確保する。  
受け取る方は普通に `struct command *` でよい。

```c
struct command {
    FILE *f;
    char *command;
};
```

コマンドの文字列を `command.command` にコピーするため `tal_arrz()` で `char` の配列っぽくメモリを確保する。  
コマンド間を区切るスペースが一つと `\0` がいるので `+ 2` されている。  
第1引数は「このポインタに紐付いてますよ」ということだろうが、一体どこにその情報を保持しているのだろうね。

```c
  cmd->command = tal_arrz(cmd, char, strlen(a0) + strlen(a1) + 2);
```

その後は `strcat(cmd->command, ...)` で連結している。
ということは確保したメモリはゼロクリアされているのか。

最後に `tal_add_destructor()` でデストラクタらしきものを指定して終わり。

`popen()` でシェルを開いて流し込む、でよいのかな。

* [Ubuntu Manpage: popen, pclose - プロセスとの入力/出力用のパイプストリーム](https://manpages.ubuntu.com/manpages/kinetic/ja/man3/popen.3.html)

`tal` で確保したアドレスは `main()` に返す。  
ん、`fprintf()` の第2引数はどういう意味があるんだ？ 
`echo "This is a test\n" | cmd hello` みたいな感じか？ 
第2引数がファイル名になっていてパイプで文字列を受け取るコマンドが思いつかない。

まあ、そこは本題ではないからよしとしよう。  
その後、最初に確保した `struct command *` だけ `tal_free()` して終わっている。
このタイミングでデストラクタが呼ばれるのだ。

`popen()` した中身は `pclose()` で実行された？  
いや、`popen()` でプロセスをオープンして実行するので単に出力のタイミングがそうなっただけか。  
`pclose()` で通常はプロセスが終わるまで待つのだから `tal_free()` で同期が取れることになる。

### valgrind

しかし、`valgrind` すると 6ブロックくらい残っているように出てきた。  
なんでだ？

あ、最初の方に `SIGPIPE` が起きたと出ていた。  
そういうものなんだ。

```
Process terminating with default action of signal 13 (SIGPIPE)
```

雑に `signal(SIGPIPE, SIG_IGN);` を追加すると全部解放されていた。
よかったよかった。

しかしこのプログラムで 7つも動的に確保するんだな。
`tal` 関係でメモリを確保しそうなのが 2箇所だったのでちょっとびっくりだ。

