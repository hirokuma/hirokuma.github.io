---
layout: post
title: "rust: thiserror で自作のエラー型を作る"
tags:
  - rust
date: "2025/12/14"
---

Rust のエラーに悩むシリーズだ。  
今まではログに悩むシリーズだったが、エラーをどう扱えばよいかわかっていないと考えづらくなってきたと感じてきた。

* [rust: Err(e)で関数名を出力したい - hiro99ma blog](https://blog.hirokuma.work/2025/11/20251130-rst.html)
* [rust: anyhow::Context はどう使うとよいだろう - hiro99ma blog](https://blog.hirokuma.work/2025/12/20251207-rst2.html)
* [rust: tracing_subscriber は RUST_LOG より実装が優先 - hiro99ma blog](https://blog.hirokuma.work/2025/12/20251209-rst.html)

## 私のログ方針

今のところ、私が実装するときはログをこうしようと思っている。  
方針というほどのものは無いな。
「こういうときは trace だけどここは debug」みたいな基準はまだできていない。
小さい組み込み開発がメインだったのでログ出力が「GPIO の ON/OFF パターン」くらいしかできないことが多かった影響で未だに苦手なのだ(言い訳)。

* 出力部分はなるべく [rust-lang/log](https://github.com/rust-lang/log) の `log::*` シリーズで書く
  * `tracing` に依存するとアプリも `tracing_subscriber` を使うことになりそうなので、少なくとも外部提供するライブラリはそうした方がよいだろう
  * 自分で使うだけだったらそこまで気にしなくてよいと思う
  * 私が `tracing` と `tracing_subscriber` しか使ったことが無いので、他のには言及しない。。。
    * だって `axum` も `tokio` も `tracing` も `tracing_subscriber` も [tokio-rs](https://github.com/tokio-rs) だから相性がよさそうじゃないか。。。
* `#[tracing::instrument]` は関数の頭に付けるだけで使えるので便利そうだが、それなりにパフォーマンスへの影響があるようだから使うなら上位層側がよさそう
* `tracing` の span 単位でログレベルを制御できるので利用すると良かろう
  * span を細々付けていくとそれはそれで負荷がかかるようなのでほどほどに？

実際にやってみて気付いたが、`main()` で `tracing_subscriber` を使うようにして、
そこから先は必要なときだけ `tracing::*`、そうでないときは `log::*` のログマクロを使っていると
"span" は `log::*` の方では取り扱われないのだな。  
上の方で `#[tracing::instrument]` で span を作り、その先の関数では `log::trace!()` でログ出力させると TRACE の方には span が入ってなかったのだ。
最初に挙げた「なるべく `log::*` で書く」が破綻した瞬間であった。。。

## 自作のエラー型

エラーについては `anyhow::Context` の `.context()` などで書こうと最初は考えていた。
最初に調べたときに見つけたのがそれだったからだ。  
`.context()` を使っても文字列を埋め込むことしかできないし、モジュール名と行番号しかわからないので扱いが難しいと思っていたところで `log::error!()` を知った。  
[std::result::Result::inspect_err()](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.inspect_err) でエラーが起きたときだけ `error!()` を呼ぶしくみがあるというのを知り、
それならそれでよいかと思った。

が、[前回](https://blog.hirokuma.work/2025/12/20251209-rst.html#golang-%E3%81%A7%E3%81%AE-errorsis-%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA)に `thiserror` で自分のエラー型を実装しやすくするトレイトがあることを知った。  
ライブラリによって `std::io::Error` だったり `std::string::ParseError` だったり自作だったりと型が違うエラーが返ってくるのは `anyhow::Result` を使うんだよ、というのを見たのでそればかり使っていたのだが、
エラーを使うと考えると「この関数/メソッドはエラーを返すけど何のエラーを返すかはよくわからない」というのもどうかと思ってしまった。  
まあ `anyhow::Result` でのエラーでも型識別はできるけれども `AbcLibraryError` のようなまとまりになっていた方が扱いよさそうに思う。

というのが前回 ChatGPT が「`thiserror` 版は公開API向き、`anyhow` 版は内部実装向き」と説明した理由だろうと思われる。  
まだ外部に提供するライブラリを書けるほどではないが、今のうちに `thiserror` に慣れたいところである。

### マッチガード？

その前に「The Rust Programming Language 日本語版」にエラーについて何かないか。。。あまりなかった。  
全然記憶に残っていないがマッチガードというものが載っていた。
`match` のエラーアームで `Err(e)` ではなく `Err(ref e) if e.kind() == XXX` のような感じでエラーを move せずに評価して不一致なら次の `Err(e)` に移るようなことができるらしい。

* [Resultで回復可能なエラー - The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/ch09-02-recoverable-errors-with-result.html#%E8%89%B2%E3%80%85%E3%81%AA%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%83%9E%E3%83%83%E3%83%81%E3%81%99%E3%82%8B)

このサンプルコードは英語版だと今はこの書き方になっていないし "match guard" というような言葉もなさそうだ。
確かに `Err` の下で `match` を展開した方が階層が浅くなって見やすい。

* [Matching on Different Errors](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#matching-on-different-errors)

`match` が多くて嫌なら `unwrap_or_else` を使えばいいじゃないの的な紹介もある。  
まあ、`Err(ref e)` を使う書き方は今でもエラーになるわけではないので使わないまでも知っておいて損はあるまい。

### thiserror

`thiserror` は rust-lang かと思っていたが違った。  
`async` / `await` は言語側だがエンジンはそうではないのと同じような感じだろうか。

dtolnay という人はすごいなあと思ったら `anyhow` もこの人か！  
よく使うクレートは名前しか見ていないけど、提供元が同じなものも結構あるのかもしれない。

* [dtolnay/thiserror: derive(Error) for struct and enum error types](https://github.com/dtolnay/thiserror)
* [dtolnay/anyhow: Flexible concrete Error type built on std::error::Error](https://github.com/dtolnay/anyhow)

`thiserror` と `anyhow` は対になるという表現は変だが相性が良いというか、そういう感じがする。  
`thiserror` で自前のエラーを作りやすくなったので、それを `anyhow` で扱いやすくするのだと思う。

使い方はいろいろあるのだと思うが、少なくとも私が使う分には README に書いてある程度で十分だ。

### source

`anyhow::Context` の `.context()` などを使うとエラーの履歴に文字列を挟み込める。
人間の情報としては助かるが実装で扱うには文字列だとちょっとやりづらい。

`thiserror` では `Io(#[from] io::Error)` のように `#[from} 型` とすると
`Io` エラーは `io::Error` をラップというか内包というか、そういう情報を持つことになる。  
「私のライブラリなので自分のエラー型として返しますが元はこのエラーなんですよ」みたいなことができる。

`open()` と `open_other()` はエラーで返そうとするのが `MyError` ではないので `?` を付けて `#[from]` による変換を作動させないとエラーになる。
`open_other2()` は `?` があってもなくてもエラーにならないのは `?` があるときは自動変換して何もしないような動作をしているからだろうか。

```rust
use std::{error::Error, fs::File, io};

use anyhow;
use thiserror;

#[derive(thiserror::Error, Debug)]
enum MyError0 {
    #[error("おはよう")]
    Morning(String),
}

#[derive(thiserror::Error, Debug)]
enum MyError {
    #[error("the I/O error")]
    Io(#[from] io::Error),
    #[error("other error with From")]
    Other(#[from] MyError0),
    #[error("other error no From")]
    Other2(),
}

fn open() -> Result<File, MyError> {
    Err(io::Error::new(io::ErrorKind::NotFound, "見つからない"))?
}

fn open_other() -> Result<(), MyError> {
    Err(MyError0::Morning("こんばんは".to_string()))?
}

fn open_other2() -> Result<(), MyError> {
    Err(MyError::Other2())?
}

fn main() -> anyhow::Result<()> {
    match open() {
        Ok(_file) => (),
        Err(e) => if let Some(source) = e.source() {
            eprintln!("sourceのエラー: {source} | {e} | {:?}", e);
        } else {
            eprintln!("その他のエラー: {:?}", e);
        },
    };

    match open_other() {
        Ok(_file) => (),
        Err(e) => if let Some(source) = e.source() {
            eprintln!("sourceのエラー: {source} | {e} | {:?}", e);
        } else {
            eprintln!("その他のエラー: {:?}", e);
        },
    };

    match open_other2() {
        Ok(_file) => (),
        Err(e) => if let Some(source) = e.source() {
            eprintln!("sourceのエラー: {source} | {e} | {:?}", e);
        } else {
            eprintln!("その他のエラー: {:?}", e);
        },
    };

    Ok(())
}
```

実行

```log
sourceのエラー: 見つからない | the I/O error | Io(Custom { kind: NotFound, error: "見つからない" })
sourceのエラー: おはよう | other error with From | Other(Morning("こんばんは"))
その他のエラー: Other2
```

`source()` が元のエラーそのものになるのかな。  
そして `source()` を持っていればさらにたどることができる。

`#[from]` などで自動で用意された `source()` の内容を使って `#[error]` を書くことはできない。
`#error[(transparent)]` でエラーを透過させると `source()` がなくなって from に乗っ取られる？感じになる。

```rust
    #[error(transparent)]
    Io(#[from] io::Error),
```

```log
その他のエラー: Io(Custom { kind: NotFound, error: "見つからない" })
```

`source()` を `anyhow::Error` にすると `anyhow::Result` を入れられるので場合分けしないといけなくなりそうだ。

### 何もしなくてもエラー出力？

いろいろ削って試していたのだが、ログ出力を実装していなくても `std::result::Result` のエラーを返すと標準出力にログが出力された。  
(念のため `Cargo.toml` の dependencies はコメントアウトしている。)

`Error: {:?}` で出力して終了コード `1`(`libc::EXIT_FAILURE`) にてプロセスを終了するそうだ。

```rust
fn main() -> std::result::Result<(), std::io::Error> {
    Err(std::io::Error::new(std::io::ErrorKind::NotFound, "見つからない"))
}
```

```log
Error: Custom { kind: NotFound, error: "見つからない" }
```

ChatGPT には [Termination](https://doc.rust-lang.org/std/process/trait.Termination.html) を参照と言われたが、見ても分からんかった。
まあ、プロセス終了時の特例のようだからいいんだけどね。

### inspect_err

せっかく `?` があるのにログを出力するために `match` を書くのも面倒だ。  
[inspect_err](https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect_err) というものがある。
"1.76.0 (const: unstable)"とあったので「1.76.0 から関数はあるけどまだ unstable」という意味かと思ったが、
「1.76.0 以降で stable なのだが[定数評価](https://doc.rust-lang.org/reference/const_eval.html)は unstable ということだそうだ。

```rust
use std::{fs::File, io};

use anyhow::Result;
use thiserror;
use tracing::*;
use tracing_subscriber::{EnvFilter, Layer, prelude::*};

#[derive(thiserror::Error, Debug)]
enum MyError {
    #[error(transparent)]
    Io(#[from] io::Error),
}

fn open() -> Result<File, MyError> {
    let e = io::Error::new(io::ErrorKind::NotFound, "見つからない");
    Err(MyError::Io(e))
}

fn main() -> std::result::Result<(), MyError> {
    let filter = EnvFilter::from_default_env(); // RUST_LOG環境変数反映
    tracing_subscriber::Registry::default()
        .with(
            tracing_subscriber::fmt::layer()
                .with_ansi(false) // エスケープシーケンスなし
                .with_line_number(true) // 行番号つき
                .with_filter(filter),
        )
        .init();

    open().inspect_err(|e| error!("エラー発生: {e}"))?;

    Ok(())
}
```

```log
2025-12-14T09:44:43.138183Z ERROR hello: 30: エラー発生: 見つからない
Error: Io(Custom { kind: NotFound, error: "見つからない" })
```

`main()` で使うとあまりありがたみがないが、エラーの時以外はコストを気にしなくてよさそうだし、
よいんじゃなかろうか。  


## エラーの時自動でログを出力するような便利なものは無い

`#[instrument(err)]` を除くと、エラーの時に自動でログを出力するような機構はないらしい。
作ればできるが大変みたいなことを ChatGPT だか Gemini だかが言っていた。  
もういい、そこは調べる気力が無いので信用しよう。
地道にやる。

その流れで今回のエラーについて調べていたのだ。  
`error!()` での文字列と、`anyhow::Result` を使っていたので簡易的に `anyhow::bail!()` で設定する文字列が一緒だったので
自動でなんとかならないかと思ったのだ。  
それができないのと、そもそも `anyhow::bail!()` だけなのもよろしくなかろうと思い、
自作のエラーを返して格好良くしたかった。

`anyhow::bail!()` はエラーだからまだよいとして 
`.context()` や `.with_context()` は文字列なので扱いづらいし、
ユーザに返す文字列として使うにも今ひとつな感じがする。  
下回りのエラーをそのまま返してもユーザにはわからんだろうと思って `.context()` を使ってみたが、
それよりも `thiserror` で引き取ってもらってエラーの意訳を付けてもらってから
返した方がありがたいはずだ。  

### bail!() よりも thiserror

そりゃそうだ、と言われそうだが、エラーかどうかだけわかればよいのであれば
`anyhow::bail!()` でも十分なのよね。。。  
と弱気になってはいかんな。

自作のエラー型を返すのであれば `error!()` で同じ文字列になるなどと考えることもない。

### anyhow::Context系はたぶんなくてよい

`thiserror` を使うなら直接のエラーは `source()` を見れば良い。
エラーの説明は自作エラーの型があるし `#[error]` の文字列もある。

そうなると `.context()` などを使わなくてもよいはずだ。

### inspect_err() を使ってみよう

ネットで検索しても `.inspect_err()` のことを書いているのが少ないからちょっと不安なのだが、
悪いことをしているわけでもないし積極的に使ってみようと思う。
