---
layout: post
title: "rust: エラーに悩む日々 (1)"
tags:
  - rust
date: "2025/12/14"
---

Rust のエラーに悩むシリーズだ。  
今まではログに悩むシリーズだったが、エラーをどう扱えばよいかわかっていないと考えづらくなってきたと感じてきた。

* [rust: Err(e)で関数名を出力したい - hiro99ma blog](https://blog.hirokuma.work/2025/11/20251130-rst.html)
* [rust: anyhow::Context はどう使うとよいだろう - hiro99ma blog](https://blog.hirokuma.work/2025/12/20251207-rst2.html)
* [rust: tracing_subscriber は RUST_LOG より実装が優先 - hiro99ma blog](https://blog.hirokuma.work/2025/12/20251209-rst.html)

## 私のログ方針

今のところ、私が実装するときはログをこうしようと思っている。  
方針というほどのものは無いな。
「こういうときは trace だけどここは debug」みたいな基準はまだできていない。
小さい組み込み開発がメインだったのでログ出力が「GPIO の ON/OFF パターン」くらいしかできないことが多かった影響で未だに苦手なのだ(言い訳)。

* 出力部分はなるべく [rust-lang/log](https://github.com/rust-lang/log) の `log::*` シリーズで書く
  * `tracing` に依存するとアプリも `tracing_subscriber` を使うことになりそうなので、少なくとも外部提供するライブラリはそうした方がよいだろう
  * 自分で使うだけだったらそこまで気にしなくてよいと思う
  * 私が `tracing` と `tracing_subscriber` しか使ったことが無いので、他のには言及しない。。。
    * だって `axum` も `tokio` も `tracing` も `tracing_subscriber` も [tokio-rs](https://github.com/tokio-rs) だから相性がよさそうじゃないか。。。
* `#[tracing::instrument]` は関数の頭に付けるだけで使えるので便利そうだが、それなりにパフォーマンスへの影響があるようだから使うなら上位層側がよさそう
* `tracing` の span 単位でログレベルを制御できるので利用すると良かろう
  * span を細々付けていくとそれはそれで負荷がかかるようなのでほどほどに？

## 私のエラーはこれからだ

エラーについては `anyhow::Context` の `.context()` などで書こうと最初は考えていた。
最初に調べたときに見つけたのがそれだったからだ。  
`.context()` を使っても文字列を埋め込むことしかできないし、モジュール名と行番号しかわからないので扱いが難しいと思っていたところで `log::error!()` を知った。  
[std::result::Result::inspect_err()](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.inspect_err) でエラーが起きたときだけ `error!()` を呼ぶしくみがあるというのを知り、
それならそれでよいかと思った。

が、[前回](https://blog.hirokuma.work/2025/12/20251209-rst.html#golang-%E3%81%A7%E3%81%AE-errorsis-%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA)に `thiserror` で自分のエラー型を実装しやすくするトレイトがあることを知った。  
ライブラリによって `std::io::Error` だったり `std::string::ParseError` だったり自作だったりと型が違うエラーが返ってくるのは `anyhow::Result` を使うんだよ、というのを見たのでそればかり使っていたのだが、
エラーを使うと考えると「この関数/メソッドはエラーを返すけど何のエラーを返すかはよくわからない」というのもどうかと思ってしまった。  
まあ `anyhow::Result` でのエラーでも型識別はできるけれども `AbcLibraryError` のようなまとまりになっていた方が扱いよさそうに思う。

というのが前回 ChatGPT が「`thiserror` 版は公開API向き、`anyhow` 版は内部実装向き」と説明した理由だろうと思われる。  
まだ外部に提供するライブラリを書けるほどではないが、今のうちに `thiserror` に慣れたいところである。

### マッチガード？

その前に「The Rust Programming Language 日本語版」にエラーについて何かないか。。。あまりなかった。  
全然記憶に残っていないがマッチガードというものが載っていた。
`match` のエラーアームで `Err(e)` ではなく `Err(ref e) if e.kind() == XXX` のような感じでエラーを move せずに評価して不一致なら次の `Err(e)` に移るようなことができるらしい。

* [Resultで回復可能なエラー - The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/ch09-02-recoverable-errors-with-result.html#%E8%89%B2%E3%80%85%E3%81%AA%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%83%9E%E3%83%83%E3%83%81%E3%81%99%E3%82%8B)

このサンプルコードは英語版だと今はこの書き方になっていないし "match guard" というような言葉もなさそうだ。
確かに `Err` の下で `match` を展開した方が階層が浅くなって見やすい。

* [Matching on Different Errors](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#matching-on-different-errors)

`match` が多くて嫌なら `unwrap_or_else` を使えばいいじゃないの的な紹介もある。  
まあ、`Err(ref e)` を使う書き方は今でもエラーになるわけではないので使わないまでも知っておいて損はあるまい。

### thiserror

`thiserror` は rust-lang かと思っていたが違った。  
`async` / `await` は言語側だがエンジンはそうではないのと同じような感じだろうか。

dtolnay という人はすごいなあと思ったら `anyhow` もこの人か！  
よく使うクレートは名前しか見ていないけど、提供元が同じなものも結構あるのかもしれない。

* [dtolnay/thiserror: derive(Error) for struct and enum error types](https://github.com/dtolnay/thiserror)
* [dtolnay/anyhow: Flexible concrete Error type built on std::error::Error](https://github.com/dtolnay/anyhow)

`thiserror` と `anyhow` は対になるという表現は変だが相性が良いというか、そういう感じがする。  
`thiserror` で自前のエラーを作りやすくなったので、それを `anyhow` で扱いやすくするのだと思う。

使い方はいろいろあるのだと思うが、少なくとも私が使う分には README に書いてある程度で十分だ。

### source

`anyhow::Context` の `.context()` などを使うとエラーの履歴に文字列を挟み込める。
人間の情報としては助かるが実装で扱うには文字列だとちょっとやりづらい。

`thiserror` では `Io(#[from] io::Error)` のように `#[from} 型` とすると
`Io` エラーは `io::Error` をラップというか内包というか、そういう情報を持つことになる。  
「私のライブラリなので自分のエラー型として返しますが元はこのエラーなんですよ」みたいなことができる。

```rust
use std::{error::Error, fs::File, io};

use anyhow;
use thiserror;

#[derive(thiserror::Error, Debug)]
enum MyError0 {
    #[error("おはよう")]
    Morning(String),
}

#[derive(thiserror::Error, Debug)]
enum MyError {
    #[error("the I/O error")]
    Io(#[from] io::Error),
    #[error("other error with From")]
    Other(#[from] MyError0),
    #[error("other error no From")]
    Other2(),
}

fn open() -> Result<File, MyError> {
    let e = io::Error::new(io::ErrorKind::NotFound, "見つからない");
    Err(MyError::Io(e))
}

fn open_other() -> Result<(), MyError> {
    let e = MyError0::Morning("こんばんは".to_string());
    Err(MyError::Other(e))
}

fn open_other2() -> Result<(), MyError> {
    Err(MyError::Other2())
}

fn main() -> anyhow::Result<()> {
    match open() {
        Ok(_file) => (),
        Err(e) => if let Some(source) = e.source() {
            eprintln!("sourceのエラー: {source}, {:?}", e);
        } else {
            eprintln!("その他のエラー: {:?}", e);
        },
    };

    match open_other() {
        Ok(_file) => (),
        Err(e) => if let Some(source) = e.source() {
            eprintln!("sourceのエラー: {source}, {:?}", e);
        } else {
            eprintln!("その他のエラー: {:?}", e);
        },
    };

    match open_other2() {
        Ok(_file) => (),
        Err(e) => if let Some(source) = e.source() {
            eprintln!("sourceのエラー: {source}, {:?}", e);
        } else {
            eprintln!("その他のエラー: {:?}", e);
        },
    };

    Ok(())
}
```

実行

```log
sourceのエラー: 見つからない, Io(Custom { kind: NotFound, error: "見つからない" })
sourceのエラー: おはよう, Other(Morning("こんばんは"))
その他のエラー: Other2
```

`source()` が元のエラーそのものになるのかな。  
それが `source()` を持っていればさらにたどることができるのだろう。

`source()` がなんなのかを知って使う方が実装としては楽そうだが、
`anyhow::Error` にすると `anyhow::Result` でのエラーを入れられるので場合分けしないといけなくなりそうだ。
