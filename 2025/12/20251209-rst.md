---
layout: post
title: "rust: tracing_subscriber は RUST_LOG より実装が優先"
tags:
  - rust
date: "2025/12/13"
---

Rust のログに悩むシリーズだ。

* [rust: Err(e)で関数名を出力したい - hiro99ma blog](https://blog.hirokuma.work/2025/11/20251130-rst.html)
* [rust: anyhow::Context はどう使うとよいだろう - hiro99ma blog](https://blog.hirokuma.work/2025/12/20251207-rst2.html)

`tracing_subscriber` でログを取っている。
`RUST_LOG=debug` みたいに環境変数を使うとビルドし直さなくても出力を制御できる。

自分のところのログはまあよいとして、使っているクレートも結構ログを出していた。
`trace` で見たいのだが自分のプロジェクト以外についてはそこまで求めていないし、出てきても量が多すぎて困る。
ならば、デフォルトのログは実装しておいて `RUST_LOG` で微調整できたらよいと考えた。
これがどうも簡単にはできないみたいである。

いくつか書き方はあるようだが、だいたいこんな感じらしい。
今回の提供は DeepWiki 氏である。

```rust
let filter = EnvFilter::builder()
    .with_default_directive(LevelFilter::INFO.into()) // デフォルトレベル
    .from_env_lossy() // 環境変数から
    .add_directive(Directive::from_str("hogehoge::fugafuga=info")?); // 追加分
```

この `.from_env_lossy()` が環境変数を反映しているのだが、それより後に指示を出すとそちらで上書きされてしまう。
じゃあ、先に `.add_directive()` して最後に `.from_env_lossy()` にしたらよいと思ったが、
`.from_env_lossy()` の後にしか `.add_directive()` を呼ぶことができない。
`.with_default_directive()` も複数呼べるものではないらしい。
`.parse_lossy()` は文字列で指示するタイプだが、これも同じく。
素直にやると `RUST_LOG` に対して実装側で上書きするような形にしかならんらしい。
どうしてもやりたかったら `env::var("RUST_LOG")` などで自分で読み取って文字列を作って `.parse_lossy()` せい、ということらしかった。

技があるのかもしれないが調べられていない。

こういうのを作ってみた。

* `RUST_LOG` は自分のクレートに設定するレベルと、追加のディレクティブを書くものとする
* 全体は "warn" にして、全体的にあまりログを出さないようにしておく
* 自分のクレートは面倒だけど全部列挙して指定する
* 最後に追加のディレクティブを適用

抜けはあると思うが、自分で使う分には足りそう。

```rust
pub fn log_dir<'a>(rust_log: &'a str, default_level: &'a str) -> (&'a str, &'a str) {
    let level = rust_log
        .split_once(',')
        .map(|(first, rest)| (first, rest))
        .unwrap_or((rust_log, ""));
    if log::LevelFilter::from_str(level.0).is_ok() {
        (level.0, level.1)
    } else {
        (default_level, rust_log)
    }
}

fn main() {
    let rust_log = env::var("RUST_LOG").unwrap_or_default();
    let (proj_level, other) = log_dir(&rust_log, "info");
    let filter_directives = format!("warn,my_crate1={proj_level},my_crate2={proj_level},{other}");
    ......
}
```

## instrument でごまかしたい

まだ試していないが `#[instrument]` を書いておけばコールログを出力してくれそうだ(subscriberの設定はいる)。
`err` があるとエラーのログも作るし、`ret` だとエラーではないときのログも出力しそうだ。

* [instrumentでなんとかなりそう](https://deepwiki.com/search/instrument_539e07cd-9c11-4f30-a6f6-3a0781c70650?mode=fast)

と思っていたが、引数に `std::fmt::Debug` がない型が混ざっているとダメだ。
そういうときは `#[instrument(skip(abc, def))]` のように個別にスキップしたい名前を書くか
`#[instrument(skip_all)]` と全部スキップするとよいみたい。

とりあえず `#[instrument(level = Level::DEBUG, skip_all)]` と書いてみたところ、
これだけだと別にコールログが作られるわけでもなかった。
ただ、そこから呼び出した関数でログを出力していて、その情報の前に関数名などが出力されていた。

これが tracing の説明で最初に出てくる "span" というやつか。
`level = Level::DEBUG` は `ret` や `err` を付けたときなのかと思ったが、この span でのログレベルを上書きするという意味だった。
一部だけログが出過ぎるとか、デバッグ中でここだけ詳細に見たいときに使うのかな。
デフォルトでは `ret` は INFO レベル、`err` は ERROR レベルの出力となり、上書きしたい場合は `ret(level="trace")` などのように書く。

そしてコールログというか、関数呼ばれました～関数抜けました～というログは出ない。
戻り値がない関数には `ret` や `err` が指定できない(コンパイルエラー)のだ。

### instrument だけ

```rust
use anyhow::Result;
use tracing::*;

#[instrument]
fn myfunc(value: i32) -> Result<bool> {
    if value < 2 {
        anyhow::bail!("ちいさすぎ")
    } else if value < 5 {
        Ok(true)
    } else {
        anyhow::bail!("おおきすぎ")
    }
}

#[instrument]
fn main() -> Result<()> {
    tracing_subscriber::fmt().init();

    let _ = myfunc(0).inspect_err(|e| error!("{:?}", e));
    let _ = myfunc(3).inspect_err(|e| error!("{:?}", e));
    let _ = myfunc(6).inspect_err(|e| error!("{:?}", e));
    Ok(())
}
```

実行。
"hello" はこの bin 名(`cargo new hello`)だ。

```log
2025-12-13T05:42:07.780976Z ERROR hello: ちいさすぎ
2025-12-13T05:42:07.781027Z ERROR hello: おおきすぎ
```

### ret, err 付き

```rust
use anyhow::Result;
use tracing::*;

#[instrument(ret, err)]
fn myfunc(value: i32) -> Result<bool> {
    if value < 2 {
        anyhow::bail!("ちいさすぎ")
    } else if value < 5 {
        Ok(true)
    } else {
        anyhow::bail!("おおきすぎ")
    }
}

#[instrument(ret, err)]
fn main() -> Result<()> {
    tracing_subscriber::fmt().init();

    let _ = myfunc(0).inspect_err(|e| error!("{:?}", e));
    let _ = myfunc(3).inspect_err(|e| error!("{:?}", e));
    let _ = myfunc(6).inspect_err(|e| error!("{:?}", e));
    Ok(())
}
```

実行。
直接実装していない関数 `myfunc()` と `main()` の戻り値ログが出力されている。
`main()` については外側の名前と同じになるのだな。

```log
2025-12-13T05:43:25.314830Z ERROR myfunc{value=0}: hello: error=ちいさすぎ
2025-12-13T05:43:25.314876Z ERROR hello: ちいさすぎ
2025-12-13T05:43:25.314905Z  INFO myfunc{value=3}: hello: return=true
2025-12-13T05:43:25.314920Z ERROR myfunc{value=6}: hello: error=おおきすぎ
2025-12-13T05:43:25.314927Z ERROR hello: おおきすぎ
2025-12-13T05:43:25.314931Z  INFO hello: return=()
```

### さらに level = Level::DEBUG も付ける

```rust
use anyhow::Result;
use tracing::*;

#[instrument(level = Level::DEBUG, ret, err)]
fn myfunc(value: i32) -> Result<bool> {
    if value < 2 {
        anyhow::bail!("ちいさすぎ")
    } else if value < 5 {
        Ok(true)
    } else {
        anyhow::bail!("おおきすぎ")
    }
}

#[instrument(level = Level::DEBUG, ret, err)]
fn main() -> Result<()> {
    tracing_subscriber::fmt().init();

    let _ = myfunc(0).inspect_err(|e| error!("{:?}", e));
    let _ = myfunc(3).inspect_err(|e| error!("{:?}", e));
    let _ = myfunc(6).inspect_err(|e| error!("{:?}", e));
    Ok(())
}
```

実行

```log
2025-12-13T05:46:18.035795Z ERROR hello: error=ちいさすぎ
2025-12-13T05:46:18.035834Z ERROR hello: ちいさすぎ
2025-12-13T05:46:18.035842Z ERROR hello: error=おおきすぎ
2025-12-13T05:46:18.035846Z ERROR hello: おおきすぎ
```

### ret(level)で調整

`ret` のログレベルは span ごとになる。
instrument で span が作られるので継承されるのではなく "info" に戻される。
トレースログのように見えるのでデフォルトで "trace" にできたりすればよさそうだが設定はなさそう。

```rust
use anyhow::Result;
use tracing::*;
use tracing_subscriber::{EnvFilter, Layer, prelude::*};

#[instrument(ret)]
fn mycall(value: i32) -> i32 {
    value * 2
}

#[instrument(ret(level = "trace"), err)]
fn myfunc(value: i32) -> Result<bool> {
    if value < 2 {
        anyhow::bail!("ちいさすぎ")
    } else if value < 5 {
        Ok(true)
    } else {
        anyhow::bail!("おおきすぎ")
    }
}

#[instrument(ret(level = "warn"), err)]
fn main() -> Result<()> {
    let filter = EnvFilter::from_default_env(); // RUST_LOG環境変数反映
    tracing_subscriber::Registry::default()
        .with(
            tracing_subscriber::fmt::layer()
                .with_ansi(false) // エスケープシーケンスなし
                .with_line_number(true) // 行番号つき
                .with_filter(filter),
        )
        .init();

    let _ = myfunc(mycall(0)).inspect_err(|e| error!("{:?}", e));
    let _ = myfunc(3).inspect_err(|e| error!("{:?}", e));
    let _ = myfunc(6).inspect_err(|e| error!("{:?}", e));
    Ok(())
}
```

実行

```log
$ RUST_LOG=trace cargo run
2025-12-13T05:46:54.961138Z  INFO mycall{value=0}: hello: 5: return=0
2025-12-13T05:46:54.961203Z ERROR myfunc{value=0}: hello: 10: error=ちいさすぎ
2025-12-13T05:46:54.961216Z ERROR hello: 33: ちいさすぎ
2025-12-13T05:46:54.961224Z TRACE myfunc{value=3}: hello: 10: return=true
2025-12-13T05:46:54.961232Z ERROR myfunc{value=6}: hello: 10: error=おおきすぎ
2025-12-13T05:46:54.961237Z ERROR hello: 35: おおきすぎ
2025-12-13T05:46:54.961241Z  WARN hello: 21: return=()
```

### thiserror

`thiserror` クレートを使うと標準っぽいエラーを楽に実装できるそうだ。  
Cargo.toml は `thiserror = "2"` を指定した。
これを書いている時点の最新が 2.0.17 だったのでそうしたのだが、検索すると "1" がよく出てきたのでちょっと気になる。

```rust
use anyhow::Result;
use thiserror::Error;

use tracing::*;
use tracing_subscriber::{EnvFilter, Layer, prelude::*};

#[derive(Error, Debug)]
pub enum MyError {
    #[error("too small")]
    TooSmall,
    #[error("too large")]
    TooLarge,
}

fn myfunc(value: i32) -> Result<bool> {
    if value < 2 {
        Err(MyError::TooSmall.into())
    } else if value < 5 {
        Ok(true)
    } else {
        Err(MyError::TooLarge.into())
    }
}

fn mycall(value: i32) -> Result<i32> {
    match myfunc(value) {
        Ok(_) => Ok(value * 2),
        Err(e) => Err(e),
    }
}

#[instrument(ret(level = "warn"), err)]
fn main() -> Result<()> {
    let filter = EnvFilter::from_default_env(); // RUST_LOG環境変数反映
    tracing_subscriber::Registry::default()
        .with(
            tracing_subscriber::fmt::layer()
                .with_ansi(false) // エスケープシーケンスなし
                .with_line_number(true) // 行番号つき
                .with_filter(filter),
        )
        .init();

    let _ = mycall(0).inspect_err(|e| error!("{:?}", e));
    let _ = mycall(3).inspect_err(|e| error!("{:?}", e));
    let _ = mycall(6).inspect_err(|e| error!("{:?}", e));
    Ok(())
}
```

実行

```log
2025-12-13T09:49:05.050268Z ERROR hello: 44: too small
2025-12-13T09:49:05.050324Z ERROR hello: 46: too large
2025-12-13T09:49:05.050332Z  WARN hello: 32: return=()
```

### anyhow::Error::is

`anyhow::Result` はいろいろなエラー型に対応できる。  
`e.is::<MyStringError>()` のようにして判定できるようだ。

```rust
use anyhow::Result;
use thiserror::Error;

use tracing::*;
use tracing_subscriber::{EnvFilter, Layer, prelude::*};

#[derive(Error, Debug)]
pub enum MyError {
    #[error("too small")]
    TooSmall,
    #[error("too large")]
    TooLarge,
}

fn myfunc(value: i32) -> Result<bool> {
    if value < 2 {
        Err(MyError::TooSmall.into())
    } else if value < 5 {
        Ok(true)
    } else {
        Err(MyError::TooLarge.into())
    }
}

#[derive(Error, Debug)]
#[error("{reason}")]
struct MyStringError {
    reason: String,
}

fn mycall(value: i32) -> Result<i32> {
    match myfunc(value) {
        Ok(_) => Ok(value * 2),
        Err(e) => Err(MyStringError{reason: format!("error happen: {e}")}.into()),
    }
}

fn main() -> Result<()> {
    let filter = EnvFilter::from_default_env(); // RUST_LOG環境変数反映
    tracing_subscriber::Registry::default()
        .with(
            tracing_subscriber::fmt::layer()
                .with_ansi(false) // エスケープシーケンスなし
                .with_line_number(true) // 行番号つき
                .with_filter(filter),
        )
        .init();

    let _ = mycall(0).inspect_err(|e| error!("{:?}", e));
    let _ = mycall(3).inspect_err(|e| error!("{:?}", e));
    match mycall(6).inspect_err(|e| error!("{:?}", e)) {
        Ok(v) => { println!("よし: {v}"); },
        Err(e) => {
            if e.is::<MyStringError>() {
                eprintln!("MyStringError: {e}");
            } else {
                eprintln!("その他エラー: {:#?}", e);
            }
        },
    }
    Ok(())
}
```

実行

```log
2025-12-13T10:25:11.365804Z ERROR hello: 49: error happen: too small
2025-12-13T10:25:11.365840Z ERROR hello: 51: error happen: too large
MyStringError: error happen: too large
```

## 私はどうしたものか

だんだん、私がどうしたいのか分からなくなってきた。  
他の実装はどうしているのだろう。

自分で書いた関数なら `err` を指定しておけば良い。
`.inspect_err(||)` があるとどの関数でエラーになったかわかりやすいとは思うが、面倒だ。

という予想で tokio のコードを検索したが instrument 自体がなさそうだ。
axum にもないし。

Gemini氏としては、大ざっぱにいえば「ライブラリで使うとデバッグで邪魔すぎる」という感じか。
それが正しいかどうかは分からないが、span が作られてパフォーマンスに影響するというのはうなずける。
エラーだけ出力したいなら、ログも出さないのに関数を呼ぶだけで span が作られるというのは無駄な行いだ。
ライブラリであれば `tracing` が必要になるというのも気になるかも。

そういえば、私も手間を少なくしてログを出したいというだけで何でもかんでもログを出したいわけじゃなかった。
初心を忘れてしまっている。。。

* `anyhow::Context` だけではエラーのトレースログとして使うには不十分
  * golang でいう `%w` のようにラップしていかないと途中の情報はない
  * 途中の情報がいるなら panic させた方が楽だと思う。
    * それができるのは、どこで panic するかわかるときだけかもしれんが
* `log::*` でログを出した方が自由度は高い。が出力先はコンソールやファイルなどにしかできない
* が、プログラム中でエラーログのデータを使うことは考えにくい
  * 使うならエラー値だけだろう
* `anyhow::bail!()` は文字でエラーを返すので、使いどころは人間用のエラーを返したいときだろう
  * 文字列として調べて……ということはできるだろうけど、あまりよいとは思えない
  * エラーということだけわかればよいという状況もあるから、その付加情報と割り切るのはありだと思う
    * そういう意味では `anyhow::Context` も使えるか
* ライブラリだと `anyhow::bail!()` で返すのはあまりきれいじゃない気がする。アプリだとまだありか？
  * ライブラリが `anyhow::Result` で返すとアプリは何のエラーを確認したら良いかわからんじゃないか、ということにようやく気付く
  * `thiserror` を使うと `anyhow::Result` でも扱えるエラーが実装できそうなのでがんばろう
  * cargo workspace にしてライブラリというよりは処理を分割しただけであればそのままでよいかも

ダメだ、全然まとまらん。。。

## おまけ

### clippy

このコードと、`#[instrument]` を削除したコードとで `cargo clippy` を実行すると、
後者だけ「return はいらんよ」と指摘が出た。
前者は `#[instrument]` によってコードが追加されているから指摘されないのかな？

```rust
#[instrument(ret(level = "trace"), err)]
fn myfunc(value: i32) -> Result<bool> {
    if value < 2 {
        return Err(AnyhowError::msg("ちいさすぎ"))
    } else if value < 5 {
        Ok(true)
    } else {
        return Err(AnyhowError::msg("おおきすぎ"))
    }
}
```

### inspect_err もあまり使われてない？

ログを出す方だからかもしれないが、ライブラリだと `inspect_err()` もあまり使われてないのかもしれない。

### Golang での errors.Is() のような

`anyhow::Context` で思ったのは、golang の `fmt.Errorf("%w")` の雰囲気に似ているというものだった。
と書くとなんとなく格好が良いが、覚えていたのは「golang で `"%w"` というのが `err` だけ使えた」くらいなものだ。
本当にまあ、すぐに記憶から無くなるね。。。  
そのことと、`anyhow::Error` に `is` があったことから `errors.Is()` を思い出せたので ChatGPT氏に尋ねた。

* [ChatGPT](https://chatgpt.com/share/693d5e9b-1960-8001-984f-b005b0cd336e)

```rust
use std::{io, num};

use anyhow::{Context, Result};
use thiserror::Error;

#[derive(Debug, Error)]
enum AppError {
    #[error("io error")]
    Io(#[from] io::Error),

    #[error("parse error")]
    Parse(#[from] num::ParseIntError),
}

// anyhow::Context
fn f() -> Result<()> {
    std::fs::read_to_string("x.txt")
        .context("failed to read config")?;
    Ok(())
}

fn main() {
    if let Err(e) = f() {
        println!("エラー有り");
        if e.is::<io::Error>() {
            println!("型で判定: io::Error");
        } else if e.is::<num::ParseIntError>() {
            println!("型で判定: num::ParseIntError");
        } else {
            println!("型で判定できなかった: {:?}", e);
        }

        if let Some(io) = e.downcast_ref::<io::Error>() {
            if io.kind() == io::ErrorKind::NotFound {
                println!("詳細判定: NotFound");
            } else {
                println!("詳細判定できなかった: {:?}", io.kind());
            }
        }
    }
}
```

実行

```log
エラー有り
型で判定: io::Error
詳細判定: NotFound
```

`anyhow::Context` を使っているが、これはエラーチェーンの段数に影響があるそうだ。
文字列を挟み込んでいるので、それがそのまま段数になるということだろう。

AI の言うことを丸呑みはできんが、まあ雰囲気としてはそうなるだろうことはわかる。

----

`AppError` を使うために `f()` を自作したが、これはダメだった。  
なんだろうね。

```rust
// これは間違い
fn f() -> Result<()> {
    Err(AppError::Io(io::Error::new(io::ErrorKind::NotFound, "oh no!")).into())
}
```

```log
エラー有り
型で判定できなかった: io error

Caused by:
    oh no!
```

どうも `thiserror` 版と `anyhow` 版、みたいな感じだったようで別物だそうだ。  
`thiserror` 版は公開API向き、`anyhow` 版は内部実装向きと説明されたが、今の私には理解が及ばない。  
後日調べ直そう。
