---
layout: post
title: "rust: tracing_subscriber は RUST_LOG より実装が優先"
tags:
  - rust
date: "2025/12/09"
---

Rust のログに悩むシリーズだ。

* [rust: Err(e)で関数名を出力したい - hiro99ma blog](https://blog.hirokuma.work/2025/11/20251130-rst.html)
* [rust: anyhow::Context はどう使うとよいだろう - hiro99ma blog](https://blog.hirokuma.work/2025/12/20251207-rst2.html)

`tracing_subscriber` でログを取っている。  
`RUST_LOG=debug` みたいに環境変数を使うとビルドし直さなくても出力を制御できる。

自分のところのログはまあよいとして、使っているクレートも結構ログを出していた。  
`trace` で見たいのだが自分のプロジェクト以外についてはそこまで求めていないし、出てきても量が多すぎて困る。  
ならば、デフォルトのログは実装しておいて `RUST_LOG` で微調整できたらよいと考えた。  
これがどうも簡単にはできないみたいである。

いくつか書き方はあるようだが、だいたいこんな感じらしい。  
今回の提供は DeepWiki 氏である。

```rust
let filter = EnvFilter::builder()
    .with_default_directive(LevelFilter::INFO.into()) // デフォルトレベル
    .from_env_lossy() // 環境変数から
    .add_directive(Directive::from_str("hogehoge::fugafuga=info")?); // 追加分
```

この `.from_env_lossy()` が環境変数を反映しているのだが、それより後に指示を出すとそちらで上書きされてしまう。  
じゃあ、先に `.add_directive()` して最後に `.from_env_lossy()` にしたらよいと思ったが、
`.from_env_lossy()` の後にしか `.add_directive()` を呼ぶことができない。  
`.with_default_directive()` も複数呼べるものではないらしい。  
`.parse_lossy()` は文字列で指示するタイプだが、これも同じく。  
素直にやると `RUST_LOG` に対して実装側で上書きするような形にしかならんらしい。  
どうしてもやりたかったら `env::var("RUST_LOG")` などで自分で読み取って文字列を作って `.parse_lossy()` せい、ということらしかった。

技があるのかもしれないが調べられていない。
