---
layout: post
title: "rust: tracing_subscriber は RUST_LOG より実装が優先"
tags:
  - rust
date: "2025/12/12"
---

Rust のログに悩むシリーズだ。

* [rust: Err(e)で関数名を出力したい - hiro99ma blog](https://blog.hirokuma.work/2025/11/20251130-rst.html)
* [rust: anyhow::Context はどう使うとよいだろう - hiro99ma blog](https://blog.hirokuma.work/2025/12/20251207-rst2.html)

`tracing_subscriber` でログを取っている。  
`RUST_LOG=debug` みたいに環境変数を使うとビルドし直さなくても出力を制御できる。

自分のところのログはまあよいとして、使っているクレートも結構ログを出していた。  
`trace` で見たいのだが自分のプロジェクト以外についてはそこまで求めていないし、出てきても量が多すぎて困る。  
ならば、デフォルトのログは実装しておいて `RUST_LOG` で微調整できたらよいと考えた。  
これがどうも簡単にはできないみたいである。

いくつか書き方はあるようだが、だいたいこんな感じらしい。  
今回の提供は DeepWiki 氏である。

```rust
let filter = EnvFilter::builder()
    .with_default_directive(LevelFilter::INFO.into()) // デフォルトレベル
    .from_env_lossy() // 環境変数から
    .add_directive(Directive::from_str("hogehoge::fugafuga=info")?); // 追加分
```

この `.from_env_lossy()` が環境変数を反映しているのだが、それより後に指示を出すとそちらで上書きされてしまう。  
じゃあ、先に `.add_directive()` して最後に `.from_env_lossy()` にしたらよいと思ったが、
`.from_env_lossy()` の後にしか `.add_directive()` を呼ぶことができない。  
`.with_default_directive()` も複数呼べるものではないらしい。  
`.parse_lossy()` は文字列で指示するタイプだが、これも同じく。  
素直にやると `RUST_LOG` に対して実装側で上書きするような形にしかならんらしい。  
どうしてもやりたかったら `env::var("RUST_LOG")` などで自分で読み取って文字列を作って `.parse_lossy()` せい、ということらしかった。

技があるのかもしれないが調べられていない。

こういうのを作ってみた。

* `RUST_LOG` は自分のクレートに設定するレベルと、追加のディレクティブを書くものとする
* 全体は "warn" にして、全体的にあまりログを出さないようにしておく
* 自分のクレートは面倒だけど全部列挙して指定する
* 最後に追加のディレクティブを適用

抜けはあると思うが、自分で使う分には足りそう。

```rust
pub fn log_dir<'a>(rust_log: &'a str, default_level: &'a str) -> (&'a str, &'a str) {
    let level = rust_log
        .split_once(',')
        .map(|(first, rest)| (first, rest))
        .unwrap_or((rust_log, ""));
    if log::LevelFilter::from_str(level.0).is_ok() {
        (level.0, level.1)
    } else {
        (default_level, rust_log)
    }
}

fn main() {
    let rust_log = env::var("RUST_LOG").unwrap_or_default();
    let (proj_level, other) = log_dir(&rust_log, "info");
    let filter_directives = format!("warn,my_crate1={proj_level},my_crate2={proj_level},{other}");
    ......
}
```

## instrument でごまかしたい

まだ試していないが `#[instrument]` を書いておけばコールログを出力してくれそうだ(subscriberの設定はいる)。  
`err` があるとエラーのログも作るし、`ret` だとエラーではないときのログも出力しそうだ。

* [instrumentでなんとかなりそう](https://deepwiki.com/search/instrument_539e07cd-9c11-4f30-a6f6-3a0781c70650?mode=fast)

と思っていたが、引数に `std::fmt::Debug` がない型が混ざっているとダメだ。  
そういうときは `#[instrument(skip(abc, def))]` のように個別にスキップしたい名前を書くか
`#[instrument(skip_all)]` と全部スキップするとよいみたい。

とりあえず `#[instrument(level = Level::DEBUG, skip_all)]` と書いてみたところ、
これだけだと別にコールログが作られるわけでもなかった。  
ただ、そこから呼び出した関数でログを出力していて、その情報の前に関数名などが出力されていた。

これが tracing の説明で最初に出てくる "span" というやつか。  
`level = Level::DEBUG` は何をしているか分からなかったが、たぶん `ret` や `err` を付けたときなのかな？  
できることが多すぎて調べきれないわ。。。

