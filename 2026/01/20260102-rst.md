---
layout: post
title: "rust: Commandパターンのような"
tags:
  - rust
date: "2026/01/02"
---

「こういうことしたいんだけど」とAIに質問すると、ほどほどによい回答が返ってくる。  
Commandパターンも名前は聞くがそういうやつだった。
GoF本って、書いてあること難しいよね。。。

axumを使ってREST APIのような感じでJSON-RPCのようなものを実装していた。  
呼び出されるエンドポイントが一つ、パラメータが `serde_json::Value` でもらってくるので、
コマンド名で呼び出す関数だけを変更したいと思ったのだ。  
`match` で分岐させるのが面倒なので、`HashMap` でコマンド名を使った連想配列にして関数を呼び出したい。

## 基本形？

`HashMap` のことは後回しにして、Commandパターンにするための基本形は trait を使う方法だろう。

```rust
use anyhow::Result;

trait Handler {
    fn execute(&self, value: u32) -> Result<String>;
}

struct Command1 {}
struct Command2 {
    name: String,
}

impl Handler for Command1 {
    fn execute(&self, value: u32) -> Result<String> {
        Ok(format!("command1 = {value}"))
    }
}

impl Command2 {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_owned(),
        }
    }
}

impl Handler for Command2 {
    fn execute(&self, value: u32) -> Result<String> {
        if value < 10 {
            anyhow::bail!("too small")
        }
        Ok(format!("command2 = ({} = {value})", self.name))
    }
}

fn main() -> Result<()> {
    let cmd1 = Command1 {};
    let cmd2 = Command2::new("gold");
    println!("{}", cmd1.execute(20)?);
    println!("{}", cmd2.execute(20)?);
    println!("{}", cmd2.execute(5)?);
    Ok(())
}
```

実行

```shell
command1 = 20
command2 = (gold = 20)
Error: too small
```

## HashMap

コマンド名で呼び出せるようにするなら `HashMap` だろう。  
`dyn` をつける、 `Box<>` もつける、そこまでやると trait を使うことができるようだ。

```rust
use anyhow::Result;
use std::collections::HashMap;

trait Handler {
    fn execute(&self, value: u32) -> Result<String>;
}

struct Command1 {}
struct Command2 {
    name: String,
}

impl Handler for Command1 {
    fn execute(&self, value: u32) -> Result<String> {
        Ok(format!("command1 = {value}"))
    }
}

impl Command2 {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_owned(),
        }
    }
}

impl Handler for Command2 {
    fn execute(&self, value: u32) -> Result<String> {
        if value < 10 {
            anyhow::bail!("too small")
        }
        Ok(format!("command2 = ({} = {value})", self.name))
    }
}

fn main() -> Result<()> {
    let mut handlers: HashMap<String, Box<dyn Handler>> = HashMap::new();
    handlers.insert("cmd1".to_string(), Box::new(Command1 {}));
    handlers.insert("cmd2".to_string(), Box::new(Command2::new("gold")));
    println!("{}", handlers["cmd1"].execute(20)?);
    println!("{}", handlers["cmd2"].execute(20)?);
    println!("{}", handlers["cmd2"].execute(5)?);
    Ok(())
}
```

実行

```shell
command1 = 20
command2 = (gold = 20)
Error: too small
```

## async 

### async_trait

これで `execute()` を `async` にすると面倒になる、という例を出そうとしたが、
単に `async` をつけるだけだと GitHub Copilot は「async をはずせばいいやん」とごもっともな修正をしてしまうので、
`tokio::time::sleep()` を意味なくつけている。

これでお任せすると `async_trait` を追加してさっぱりと対応してしまった。

```rust
use anyhow::Result;
use async_trait::async_trait;
use std::{collections::HashMap, time::Duration};
use tokio;

#[async_trait]
trait Handler: Send + Sync {
    async fn execute(&self, value: u32) -> Result<String>;
}

struct Command1 {}
struct Command2 {
    name: String,
}

#[async_trait]
impl Handler for Command1 {
    async fn execute(&self, value: u32) -> Result<String> {
        tokio::time::sleep(Duration::from_secs(1)).await;
        Ok(format!("command1 = {value}"))
    }
}

impl Command2 {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_owned(),
        }
    }
}

#[async_trait]
impl Handler for Command2 {
    async fn execute(&self, value: u32) -> Result<String> {
        if value < 10 {
            anyhow::bail!("too small")
        }
        tokio::time::sleep(Duration::from_secs(1)).await;
        Ok(format!("command2 = ({} = {value})", self.name))
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let mut handlers: HashMap<String, Box<dyn Handler>> = HashMap::new();
    handlers.insert("cmd1".to_string(), Box::new(Command1 {}));
    handlers.insert("cmd2".to_string(), Box::new(Command2::new("gold")));
    println!("{}", handlers["cmd1"].execute(20).await?);
    println!("{}", handlers["cmd2"].execute(20).await?);
    println!("{}", handlers["cmd2"].execute(5).await?);
    Ok(())
}
```

### `Pin<Box<>>`

async_trait を使わずにやろうとすると、`async` ではなく `Future<Output=xxx>` を返す関数に変更するよう言われる。  
で、これだけでは飽き足らず `std::pin::Pin` もいるし `Box` も使うし、`Send` も `Sync` まで出てくる。  
どうなっとるんじゃ！

```rust
use anyhow::Result;
use std::{collections::HashMap, time::Duration, pin::Pin, future::Future};
use tokio;

trait Handler: Send + Sync {
    fn execute(&self, value: u32) -> Pin<Box<dyn Future<Output = Result<String>> + Send + 'static>>;
}

struct Command1 {}
struct Command2 {
    name: String,
}

impl Handler for Command1 {
    fn execute(&self, value: u32) -> Pin<Box<dyn Future<Output = Result<String>> + Send + 'static>> {
        Box::pin(async move {
            tokio::time::sleep(Duration::from_secs(1)).await;
            Ok(format!("command1 = {value}"))
        })
    }
}

impl Command2 {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_owned(),
        }
    }
}

impl Handler for Command2 {
    fn execute(&self, value: u32) -> Pin<Box<dyn Future<Output = Result<String>> + Send + 'static>> {
        let name = self.name.clone();
        Box::pin(async move {
            if value < 10 {
                anyhow::bail!("too small")
            }
            tokio::time::sleep(Duration::from_secs(1)).await;
            Ok(format!("command2 = ({} = {value})", name))
        })
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let mut handlers: HashMap<String, Box<dyn Handler>> = HashMap::new();
    handlers.insert("cmd1".to_string(), Box::new(Command1 {}));
    handlers.insert("cmd2".to_string(), Box::new(Command2::new("gold")));
    println!("{}", handlers["cmd1"].execute(20).await?);
    println!("{}", handlers["cmd2"].execute(20).await?);
    println!("{}", handlers["cmd2"].execute(5).await?);
    Ok(())
}
```

実行

```shell
command1 = 20
command2 = (gold = 20)
Error: too small
```

困るのは、私が `Pin<Box<dyn Future<Output = Result<String>> + Send + 'static>>` という trait の戻り値を見てもわからないことだ。  
`Output = ` とあるのでかろうじて戻り値の型と推測できるかもしれないが、
`Pin::Box<<>>` を見ておびえるだろうし、関数の中で `Box::pin(async move { ~ })` を使うことになるだろうと予想もしないだろう。

しかし他に書きようもないようだし、慣れるか async_trait を使うしかなさそうに思う。
