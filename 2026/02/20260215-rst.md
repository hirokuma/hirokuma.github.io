---
layout: post
title: "rust: FnOnce?"
tags:
  - rust
create: "2026/02/15"
date: "2026/02/15"
---

Rustの本を読んでいると `Fn` トレイト3種(`Fn`, `FnOnce`, `FnMut`)が紹介されていた。
クロージャを実装するときは `|～| {～}` のように書くだけだが、それを引数に取りたいときは `fn` ではなく `Fn` トレイトのどれかを使うそうだ。  
クロージャの外側の変数を使わない(キャプチャーしない)のであれば `fn` でもよいらしい。
単に名前がついていないだけの関数ということなのだろう。

`print()` は `fn` を引数に取るがそれ以外はそれぞれの `Fn` トレイトを使っている。
ただ、これは `Fn` や `FnOnce` の違いを表すのに適したサンプルコードではなかった。

```rust
fn main() {
    let greet = "Hello";

    let func_nocap = |name: &str| {
        format!("func: Hi {}!", name)
    };
    let func = |name: &str| {
        format!("func: {} {}!", greet, name)
    };
    let func_once = |name: &str| {
        format!("func_once: {} {}!", greet, name)
    };
    let mut func_mut = |name: &str| {
        format!("func_mut: {} {}!", greet, name)
    };

    print(func_nocap, "Tom");
    print_fn(func, "Tom");
    print_fn_once(func_once, "Tom");
    print_fn_mut(&mut func_mut, "Tom");
}

fn print(func: fn (&str) -> String, name: &str) {
    println!("{}", func(name));
}

fn print_fn(func: impl Fn(&str) -> String, name: &str) {
    println!("{}", func(name));
}

fn print_fn_once(func: impl FnOnce(&str) -> String, name: &str) {
    println!("{}", func(name));
}

fn print_fn_mut(func: &mut impl FnMut(&str) -> String, name: &str) {
    println!("{}", func(name));
}
```

```log
func: Hi Tom!
func: Hello Tom!
func_once: Hello Tom!
func_mut: Hello Tom!
```

### 適してないのはなぜ？

このサンプルコードがサンプルになっていないのは、関数の引数としてはともかくクロージャ自体が `FnOnce` になっていないからだ。
`FnMut` が内部でキャプチャした値を更新するように、`FnOnce` も内部でキャプチャした値の所有権を奪わないとそうならない。

`&str` だと参照でわかりにくいので `struct Greet` にしてしまおう。

```rust
struct Greet {
    greet: String,
}

fn closure_fn() {
    let greet = Greet {
        greet: "Hello".to_owned(),
    };

    let func = |name: &str| {
        format!("func: {} {}!", greet.greet, name)
    };
    print_fn(func, "Tom");
    print_fn_once(func, "Tom");
    print_fn_once(func, "Tom");
    print_fn(func, "Tom");
}

fn closure_fnonce() {
    let greet = Greet {
        greet: "Hello".to_owned(),
    };

    let func_once = |name: &str| {
        let g = greet; // ★所有権を奪うことでFnOnceと判定される
        format!("func_once: {} {}!", g.greet, name)
    };
    // print_fn(func_once, "Tom"); ★コンパイルエラーになる
    print_fn_once(func_once, "Tom");
    // print_fn_once(func_once, "Tom"); ★コンパイルエラーになる
}

fn closure_fnmut() {
    let mut greet = Greet {
        greet: "Hello".to_owned(),
    };
    let mut func_mut = |name: &str| {
        let res = format!("func_mut: {} {}!", greet.greet, name);
        greet.greet = "Hi".to_owned();
        res
    };

    // print_fn(&func_mut, "Tom"); ★コンパイルエラーになる
    print_fn_mut(&mut func_mut, "Tom");
    print_fn_mut(&mut func_mut, "Tom");
}

fn main() {
    closure_fn();
    closure_fnonce();
    closure_fnmut();
}

fn print_fn(func: impl Fn(&str) -> String, name: &str) {
    println!("print_fn: {}", func(name));
}

fn print_fn_once(func: impl FnOnce(&str) -> String, name: &str) {
    println!("print_fn_once: {}", func(name));
}

fn print_fn_mut(func: &mut impl FnMut(&str) -> String, name: &str) {
    println!("print_fn_mut: {}", func(name));
}
```

## キャプチャするのはクロージャがある方の環境

`greet` をキャプチャしているが、もちろんこれはクロージャが存在する環境にある `greet` を参照している。  
`print_fn()` などの中に `let greet` で定義しても参照されない。

## FnOnceはどこで使うの？

クロージャの所有権を奪って何のメリットがあるんだろう？  
よくわからんのでGemini氏に聞いたところ、1回しか使わないことを明示的にできるとのこと。
そりゃそうなんだけど、普通の関数やメソッドにはそういうことができないので気になる。

よく使われるのはスレッドを作るときだそうだ。
スレッドに渡すデータは所有権を全部渡すことになるのでクロージャごと所有権を持っていってしまえ、ということらしい。  
私が使ったことがあるのは `tokio::spawn()` くらいで常駐するものしかなかったから `Arc` やら `Mutex` やらでガチガチに固めたけど、
ちょっとした処理を並列化するだけだと忘れてしまうかもしれない。
