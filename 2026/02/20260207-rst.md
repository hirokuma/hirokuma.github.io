---
layout: post
title: "rust: tokio::taskは公平だ"
tags:
  - rust
create: "2026/02/07"
date: "2026/02/07"
---

作っているRustのプログラムで最近悩んでいるのが非同期タスクのタスクスイッチについてだ。  
よくあるように `tokio::spawn()` で立ち上げて `loop{}` でぐるぐる回している。
タスク間でメッセージを送ったりそれを待ったりするので `tokio::sync::mpsc` を使っている。

その中に、ときどき重たいタスクがある。
タスクが呼んでいるメソッドがなかなか戻ってこないというだけで実際に重たいかどうかは見てない。  
私が調べたところでは `.await` するとタスクマネージャーに戻すそうで、
そういうシーンがなくて戻したいなら `tokio::task::yield_now()` を使うと良いそうだ。

* [yield_now in tokio::task - Rust](https://docs.rs/tokio/latest/tokio/task/fn.yield_now.html)
* [rust: tokio::broadcast と tokio::mpsc の recv はちょっと違う - hiro99ma blog](https://blog.hirokuma.work/2025/11/20251128-rst.html)

`tokio` のタスク設計方針として、公平性があるとGeminiはいう。
この辺のブログだそうだ。すまん、読んでない。

* [Making the Tokio scheduler 10x faster - Tokio - An asynchronous Rust runtime](https://tokio.rs/blog/2019-10-scheduler)
* [Reducing tail latencies with automatic cooperative task yielding - Tokio - An asynchronous Rust runtime](https://tokio.rs/blog/2020-04-preemption)

明示的に `yield_now()` を呼ばなくても budget が消費されると自動的に同じことをする、とかなんとか。。。  
再実行するタスクは1つ前のものが優先されるとかなんとか。。。

と、ともかくだ。  
何も考えずに実装してもある程度はタスクが回ってくれるけれども、
優先したいタスクがあるなら工夫しないといけないのだろう。

今困っているのも、ネットワークで受信したら処理を始めるようになっているのに
処理が行われないし受信したログも出てこない、というものだ。  
いや、ログが出ないのは期待したタイミングになっていないというだけで
ずいぶんと遅延して処理が行われているのだが、あまりにも遅れすぎてダメダメになっている。

重たい処理は `spawn_blocking{}` でタスクスイッチしつつ裏で動かす、みたいな対処をするらしい。
それで回避できるかなあ。できてほしいなあ。。。

* ループしているならカウンタなどを使いつつ定期的に `tokio::task::yield_now()`
* `.await` しなくて時間がかかるメソッドは `tokio::task::spawn_blocking(move || {...})` を使って処理を逃がす

## 実験

やってみよう。

```toml
[dependencies]
tokio = { version = "1.49.0", features = ["full"] }
tracing = "0.1.44"
tracing-subscriber = "0.3.22"
```

### その1: std::thread::sleep

task1とtask2を立ち上げ、task2は `tokio::time::sleep()` ではなく `std::thread::sleep()` を使っているので
`.await` によってタスクスケジューラに戻されるタイミングがないので、tokio の公平性によってしばらく待たないとtask1に処理が戻ってこない、
という予想。  
`flavor = "current_thread"` がないとマルチスレッドで動くためかtask1とtask2はまったく影響されずに動いてしまった。

```rust
#[tokio::main(flavor = "current_thread")]
async fn main() {
    tracing_subscriber::fmt::Subscriber::builder().init();
    let t1 = tokio::spawn(task1());
    let t2 = tokio::spawn(task2());
    tokio::select! {
        _ = t1 => { tracing::error!("t1 has ended"); },
        _ = t2 => { tracing::error!("t2 has ended"); },
    }
}

async fn task1() {
    loop {
        tracing::info!("task1 begin");
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        tracing::info!("task1 end");
    }
}

async fn task2() {
    loop {
        tracing::info!("task2 begin");
        // tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
        std::thread::sleep(std::time::Duration::from_secs(5));
        tracing::info!("task2 end");
    }
}
```

・・・はい、予想と違いました。

```log
2026-02-07T12:25:55.151415Z  INFO spawn_blocking: task1 begin
2026-02-07T12:25:55.151465Z  INFO spawn_blocking: task2 begin
2026-02-07T12:26:00.151762Z  INFO spawn_blocking: task2 end
2026-02-07T12:26:00.151864Z  INFO spawn_blocking: task2 begin
2026-02-07T12:26:08.606309Z  INFO spawn_blocking: task2 end
2026-02-07T12:26:08.606407Z  INFO spawn_blocking: task2 begin
2026-02-07T12:26:13.606496Z  INFO spawn_blocking: task2 end
2026-02-07T12:26:13.606548Z  INFO spawn_blocking: task2 begin
2026-02-07T12:26:18.606739Z  INFO spawn_blocking: task2 end
2026-02-07T12:26:18.606804Z  INFO spawn_blocking: task2 begin
2026-02-07T12:26:23.606964Z  INFO spawn_blocking: task2 end
2026-02-07T12:26:23.607095Z  INFO spawn_blocking: task2 begin
......
```

tokioの公平性が発揮されるのはスケジューラに戻されるからできるのであって、
`.await` がないこの状況ではひたすらtask2に奪われ続けてしまうのであった。  
まあ、これはこれでわかりやすくてよい。

### その2: spawn_blocking

`std::thread::sleep()` を `tokio::task::spawn_blocking` で囲む。

```rust
async fn task2() {
    loop {
        tracing::info!("task2 begin");
        // tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
        tokio::task::spawn_blocking(move || {
            std::thread::sleep(std::time::Duration::from_secs(5));
        }).await.unwrap();
        tracing::info!("task2 end");
    }
}
```

task1は1秒ごと、task2は5秒ごとに動いている。

```log
2026-02-07T12:26:47.603698Z  INFO spawn_blocking: task1 begin
2026-02-07T12:26:47.603761Z  INFO spawn_blocking: task2 begin
2026-02-07T12:26:48.605260Z  INFO spawn_blocking: task1 end
2026-02-07T12:26:48.605405Z  INFO spawn_blocking: task1 begin
2026-02-07T12:26:49.606741Z  INFO spawn_blocking: task1 end
2026-02-07T12:26:49.606871Z  INFO spawn_blocking: task1 begin
2026-02-07T12:26:50.608358Z  INFO spawn_blocking: task1 end
2026-02-07T12:26:50.608477Z  INFO spawn_blocking: task1 begin
2026-02-07T12:26:51.609817Z  INFO spawn_blocking: task1 end
2026-02-07T12:26:51.610103Z  INFO spawn_blocking: task1 begin
2026-02-07T12:26:52.604541Z  INFO spawn_blocking: task2 end
2026-02-07T12:26:52.604733Z  INFO spawn_blocking: task2 begin
2026-02-07T12:26:52.611208Z  INFO spawn_blocking: task1 end
2026-02-07T12:26:52.611310Z  INFO spawn_blocking: task1 begin
2026-02-07T12:26:53.612494Z  INFO spawn_blocking: task1 end
2026-02-07T12:26:53.612654Z  INFO spawn_blocking: task1 begin
```
