---
layout: post
title: "rust: tokio::taskは公平だ"
tags:
  - rust
create: "2026/02/07"
date: "2026/02/07"
---

作っているRustのプログラムで最近悩んでいるのが非同期タスクのタスクスイッチについてだ。  
よくあるように `tokio::spawn()` で立ち上げて `loop{}` でぐるぐる回している。
タスク間でメッセージを送ったりそれを待ったりするので `tokio::sync::mpsc` を使っている。

その中に、ときどき重たいタスクがある。
タスクが呼んでいるメソッドがなかなか戻ってこないというだけで実際に重たいかどうかは見てない。  
私が調べたところでは `.await` するとタスクマネージャーに戻すそうで、
そういうシーンがなくて戻したいなら `tokio::task::yield_now()` を使うと良いそうだ。

* [yield_now in tokio::task - Rust](https://docs.rs/tokio/latest/tokio/task/fn.yield_now.html)
* [rust: tokio::broadcast と tokio::mpsc の recv はちょっと違う - hiro99ma blog](https://blog.hirokuma.work/2025/11/20251128-rst.html)

`tokio` のタスク設計方針として、公平性があるとGeminiはいう。
この辺のブログだそうだ。すまん、読んでない。

* [Making the Tokio scheduler 10x faster - Tokio - An asynchronous Rust runtime](https://tokio.rs/blog/2019-10-scheduler)
* [Reducing tail latencies with automatic cooperative task yielding - Tokio - An asynchronous Rust runtime](https://tokio.rs/blog/2020-04-preemption)

明示的に `yield_now()` を呼ばなくても budget が消費されると自動的に同じことをする、とかなんとか。。。  
再実行するタスクは1つ前のものが優先されるとかなんとか。。。

と、ともかくだ。  
何も考えずに実装してもある程度はタスクが回ってくれるけれども、
優先したいタスクがあるなら工夫しないといけないのだろう。

今困っているのも、ネットワークで受信したら処理を始めるようになっているのに
処理が行われないし受信したログも出てこない、というものだ。  
いや、ログが出ないのは期待したタイミングになっていないというだけで
ずいぶんと遅延して処理が行われているのだが、あまりにも遅れすぎてダメダメになっている。

重たい処理は `spawn_blocking{}` でタスクスイッチしつつ裏で動かす、みたいな対処をするらしい。
それで回避できるかなあ。できてほしいなあ。。。
