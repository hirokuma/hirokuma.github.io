---
layout: post
title: "rust: anyhow::Resultからの脱却"
tags:
  - rust
create: "2026/02/17"
date: "2026/02/17"
draft: true
---

ライブラリを使っていて、関数の戻り値が `Result<T, ErrorA>` だった。  
その関数を呼出した自作関数の中でまた別のライブラリの関数を使ったのだが、これの戻り値は `Result<T, ErrorB>` だった。  
違うライブラリなので `ErrorA` と `ErrorB` は別物。  
しかし私は自作関数の中でエラー処理せず上に丸投げするつもりだった。  
さあ、どうする？

となったときに知ったのが `anyhow::Result` だった。  
これを使いさえすればすべてが許される、ああなんて楽なんだ！  
`anyhow::Result` があれば何もいらない。。。

そう思っていたが、自作ライブラリのエラーに統一感がない・・・
いや `anyhow::Result` になっているという点では統一されているのだが、
自分でエラーにするときは `anyhow::bail!()` なので文字列になっている。  
さすがにちょっとよろしくないと思い始めた。

## thiserror

自作のエラーを追加するときは `thiserror` クレートを使うと楽になるそうだ。
[過去](https://duckduckgo.com/?q=%22thiserror%22+site%3Ablog.hirokuma.work&atb=v491-1&ia=web)に数回やっているのだがまったく記憶にない。  
いつでも新鮮だ。

```rust
use anyhow::Result;

fn main() -> Result<()> {
    my_func()
}

fn my_func() -> Result<()> {
    other_func()
}

fn other_func() -> Result<()> {
    anyhow::bail!("other_func error")
}
```

これを `main()` に接するところだけ自作エラーの `MyError` に対応して、
そこから先は空き時間を見てやっていこう、というやり方でもよい。  
いや、よくはないのだろうが、そういうこともできる。

```rust
use anyhow::Result;
use thiserror::Error;

fn main() -> Result<()> {
    my_func()?;
    Ok(())
}


#[derive(Error, Debug)]
pub enum MyError {
    #[error("my error")]
    Any(#[from] anyhow::Error),
}

fn my_func() -> std::result::Result<(), MyError> {
    other_func()?;
    Ok(())
}

fn other_func() -> Result<()> {
    anyhow::bail!("other_func error")
}
```
