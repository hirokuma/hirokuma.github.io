---
layout: post
title: "rust: anyhow::Resultからの脱却"
tags:
  - rust
create: "2026/02/17"
date: "2026/02/17"
draft: true
---

ライブラリを使っていて、関数の戻り値が `Result<T, ErrorA>` だった。  
その関数を呼出した自作関数の中でまた別のライブラリの関数を使ったのだが、これの戻り値は `Result<T, ErrorB>` だった。  
違うライブラリなので `ErrorA` と `ErrorB` は別物。  
しかし私は自作関数の中でエラー処理せず上に丸投げするつもりだった。  
さあ、どうする？

となったときに知ったのが `anyhow::Result` だった。  
これを使いさえすればすべてが許される、ああなんて楽なんだ！  
`anyhow::Result` があれば何もいらない。。。

そう思っていたが、自作ライブラリのエラーに統一感がない・・・
いや `anyhow::Result` になっているという点では統一されているのだが、
自分でエラーにするときは `anyhow::bail!()` なので文字列になっている。  
さすがにちょっとよろしくないと思い始めた。

## thiserror

自作のエラーを追加するときは `thiserror` クレートを使うと楽になるそうだ。
[過去](https://duckduckgo.com/?q=%22thiserror%22+site%3Ablog.hirokuma.work&atb=v491-1&ia=web)に数回やっているのだがまったく記憶にない。  
いつでも新鮮だ。

```rust
use anyhow::Result;

fn main() -> Result<()> {
    my_func()
}

fn my_func() -> Result<()> {
    other_func()
}

fn other_func() -> Result<()> {
    anyhow::bail!("other_func error")
}
```

これを `main()` に接するところだけ自作エラーの `MyError` に対応して、
そこから先は空き時間を見てやっていこう、というやり方でもよい。  
いや、よくはないのだろうが、そういうこともできる。

```rust
use anyhow::Result;
use thiserror::Error;

fn main() -> Result<()> {
    my_func()?;
    Ok(())
}

#[derive(Error, Debug)]
pub enum MyError {
    #[error("my error")]
    Any(#[from] anyhow::Error),
}

fn my_func() -> std::result::Result<(), MyError> {
    other_func()?;
    Ok(())
}

fn other_func() -> Result<()> {
    anyhow::bail!("other_func error")
}
```

```log
Error: my error

Caused by:
    other_func error
```

### 同じ系統のエラーを内包する

`#[from]` は自動変換してくれるようで `map_err()` などしなくてもコンパイルできた。

ここでは `Any` にまとめたのだが、じわじわ修正したいのでまずアプリに向けて見せるエラーを分けてから内側で返している `anyhow::Error` を対応していきたい。
つまりこういう感じにしたいのだが、これはコンパイルエラーになる。

```rust
pub enum MyError {
    Any1(#[from] anyhow::Error),
    Any2(#[from] anyhow::Error), // ★ここのfromがダメ
}
```

`from` がコンフリクトするからダメなのだと。  
つまり `#[from] 型` が同じにならないようにしておけばよい。
`from` がない方を使いたければ `map_err()` で変換する。  
最終的には下の方もエラーを整理して全部 `from` で書けるようになるかもしれないので無駄になるかもしれないが、
最初にエラーを設計せずに作業した罰だと思って受け入れよう。

```rust
use anyhow::Result;
use thiserror::Error;

fn main() -> Result<()> {
    let _ = my_func1().inspect_err(|e| println!("エラーだけどスルー: {e}"));
    my_func2()?;
    Ok(())
}

#[derive(Error, Debug)]
pub enum MyError {
    #[error("my error1: {0}")]
    Any1(#[from] anyhow::Error),
    #[error("my error2: {0}")]
    Any2(anyhow::Error),
}

fn my_func1() -> std::result::Result<(), MyError> {
    other_func()?;
    Ok(())
}

fn my_func2() -> std::result::Result<(), MyError> {
    other_func().map_err(MyError::Any2)?;
    Ok(())
}

fn other_func() -> Result<()> {
    anyhow::bail!("other_func error")
}
```

```log
エラーだけどスルー: my error1: other_func error
Error: my error2: other_func error
```

