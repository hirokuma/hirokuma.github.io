---
layout: post
title: "rust: NDJSON streaming"
tags:
  - rust
create: "2026/02/11"
date: "2026/02/11"
---

## 発端

今作っているRustのアプリで、REST APIを呼び出すと大量のJSONデータを返すようになってしまった。  
調べてないがこんなエラーが出てきた。

```text
Error: json: the response body is larger than request limit: 10485760 at line 1 column 10485760
```

10MBはさすがに大きいか。

最初は「大量のJSONデータが来ても出力できるようにしなきゃ」などと思っていたが、
そもそもこんなに大量のデータを一気に返したらダメだよなと気づいた。

ならどうするかというと、たぶん1回のデータ量を制限して数回に分けることができるようにする、なのだと思う。
ストリーミングにしてというやり方もあるかもしれないが、REST APIだとそうなるんじゃなかろうか。

## KVS

大量のデータ元はデータベースだ。  
他と共有することもないので組み込み型でよかろうと[redb](https://www.redb.org/)を使っている。
このredbはKey-Value store型である。
redbを選択した理由は、検索して最初の方に出てきたからだ。
GitHubのスター数も4.2Kくらいあるのでそこそこ使われているだろうというのも判断材料になっている。

今回使いたい取得する系統のメソッドには `get()` `range(start..end)` `iter()` があるそうだ。  
範囲の指定もKVSのkeyについてだけなので、SQL慣れしていない私にとっては気が楽かな。

## pagenation

名前は知っているもののほとんど実装したことがないpagenation。  
やり方は色々あるのだろうが、難しい、という印象が残っている。

データが変化しないなら良いが、たとえば新しい順で1ページ目を取得した後に新規で1件のデータが追加されたときどうするか、
というような考慮がいるはずだ。  
記憶をたどると・・・たしか取得したいページ番号だけでなく取得した最後だかその次(新しい順だと古い方向に次)を具体的に示す値も与えていた気がする。  
これ以上は自力でやっても仕方ないな。

* [Gemini](https://gemini.google.com/share/8248b14ad939)

なるほど、「オフセット方式」と「カーソル方式」があって以前私が扱ったのはカーソル方式だったことになる。  
SQLだと方式によって負荷がどうのこうのあるようだが、KVSだと自分で実装するし

## streaming

とはいえ、pagenationだと呼ばれるたびにDBを全部さらって一部だけデータを切り出して返す、というのを繰り返すのでサーバの負荷が大きい。  
やっぱり嫌だなあと調べていくと NDJSON(Newline Delimited JSON)形式のストリーミングという案を出してくれた。

NDJSONは、JSON形式のログでよくあるような1行で完結するJSONが複数行あるタイプらしい。  

### 試作

Geminiがサンプルコードを作ってくれたので、形を整えた。  
使っているのは axum と ureq である。

* [repository](https://github.com/hirokuma/ndjson-response)
